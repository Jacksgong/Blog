{
  "_args": [
    [
      {
        "raw": "dtrace-provider@~0.8",
        "scope": null,
        "escapedName": "dtrace-provider",
        "name": "dtrace-provider",
        "rawSpec": "~0.8",
        "spec": ">=0.8.0 <0.9.0",
        "type": "range"
      },
      "/Users/Jacksgong/code/github/blog/node_modules/bunyan"
    ]
  ],
  "_from": "dtrace-provider@>=0.8.0 <0.9.0",
  "_id": "dtrace-provider@0.8.1",
  "_inCache": true,
  "_location": "/dtrace-provider",
  "_nodeVersion": "0.10.46",
  "_npmOperationalInternal": {
    "host": "packages-18-east.internal.npmjs.com",
    "tmp": "tmp/dtrace-provider-0.8.1.tgz_1488913310577_0.9861480239778757"
  },
  "_npmUser": {
    "name": "melloc",
    "email": "cody.mello@joyent.com"
  },
  "_npmVersion": "2.15.1",
  "_phantomChildren": {},
  "_requested": {
    "raw": "dtrace-provider@~0.8",
    "scope": null,
    "escapedName": "dtrace-provider",
    "name": "dtrace-provider",
    "rawSpec": "~0.8",
    "spec": ">=0.8.0 <0.9.0",
    "type": "range"
  },
  "_requiredBy": [
    "/bunyan"
  ],
  "_resolved": "https://registry.npmjs.org/dtrace-provider/-/dtrace-provider-0.8.1.tgz",
  "_shasum": "cd4d174a233bea1bcf4a1fbfa5798f44f48cda9f",
  "_shrinkwrap": null,
  "_spec": "dtrace-provider@~0.8",
  "_where": "/Users/Jacksgong/code/github/blog/node_modules/bunyan",
  "author": {
    "name": "Chris Andrews",
    "email": "chris@nodnol.org"
  },
  "bugs": {
    "url": "https://github.com/chrisa/node-dtrace-provider/issues"
  },
  "dependencies": {
    "nan": "^2.3.3"
  },
  "description": "Native DTrace providers for node.js applications",
  "devDependencies": {
    "tap": "^0.2.0"
  },
  "directories": {},
  "dist": {
    "shasum": "cd4d174a233bea1bcf4a1fbfa5798f44f48cda9f",
    "tarball": "https://registry.npmjs.org/dtrace-provider/-/dtrace-provider-0.8.1.tgz"
  },
  "engines": {
    "node": ">=0.10"
  },
  "gitHead": "a1594b0ea17b6ba2329b0bf4160e91c892777004",
  "homepage": "https://github.com/chrisa/node-dtrace-provider#readme",
  "keywords": [
    "dtrace",
    "usdt"
  ],
  "license": "BSD-2-Clause",
  "main": "./dtrace-provider.js",
  "maintainers": [
    {
      "name": "chrisa",
      "email": "chris@nodnol.org"
    },
    {
      "name": "dap",
      "email": "dap@cs.brown.edu"
    },
    {
      "name": "melloc",
      "email": "cody.mello@joyent.com"
    },
    {
      "name": "tjfontaine",
      "email": "tjfontaine@gmail.com"
    }
  ],
  "name": "dtrace-provider",
  "optionalDependencies": {},
  "readme": "# dtrace-provider - Native DTrace providers for Node.js apps.\n\nThis extension allows you to create native DTrace providers for your\nNode.js applications. That is, to create providers and probes which\nexpose information specific to your application, rather than\ninformation about the node runtime.\n\nYou could use this to expose high-level information about the inner\nworkings of your application, or to create a specific context in which\nto look at information from other runtime or system-level providers. \n\nThe provider is not created in the usual way, by declaring it and then\nchanging the build process to include it, but instead dynamically at\nruntime. This is done entirely in-process, and there is no background\ncompiler or [dtrace(1M)](https://illumos.org/man/1M/dtrace) invocation.\nThe process creating the provider need not run as root.\n\n## INSTALL\n\n    $ npm install dtrace-provider\n\n## EXAMPLE\n\nHere's a simple example of creating a provider:\n\n```javascript\nvar d = require('dtrace-provider');\n\nvar dtp = d.createDTraceProvider(\"nodeapp\");\nvar p1 = dtp.addProbe(\"probe1\", \"int\", \"int\");\nvar p2 = dtp.addProbe(\"probe2\", \"char *\");\ndtp.enable();\n```\n\nProbes may be fired via the provider object:\n\n```javascript\ndtp.fire(\"probe1\", function() {\n    return [1, 2];\n});\ndtp.fire(\"probe2\", function() {\n    return [\"hello, dtrace via provider\", \"foo\"];\n});\n```\n\nor via the probe objects themselves:\n\n```javascript\np1.fire(function() {\n  return [1, 2, 3, 4, 5, 6];\n});\np2.fire(function() {\n  return [\"hello, dtrace via probe\", \"foo\"];\n});\n```\n\nNote that `.fire()` takes a callback that returns the arguments to be\nprovided when the DTrace probe actually fires. This allows you to call\n`.fire()` unconditionally when you want to fire the probe, but the\ncallback will be invoked only when the DTrace probe is actually\nenabled. This allows you to create probes whose arguments might be\nexpensive to construct, and only do any work when the probe is\nactually enabled. (Examples might include converting a large object to\na string representation or gathering large amounts of information.)\n\nIn some cases, creating a new closure to pass to `.fire()` each time\nit's called may introduce unwanted overhead. For extremely\nCPU-intensive or memory-conscious workloads, you can avoid this by\nlifting the closures for your hot probes into an outer scope. You can\nthen supply arguments to that function as additional arguments to\n`.fire()`. As an example, you can convert the following program:\n\n```javascript\nfunction manipulateObj(largeObj) {\n    var count = 0;\n    var name = null;\n    ...\n    p1.fire(function () {\n        return [count, keyToValue(name), JSON.stringify(largeObj)];\n    });\n}\n```\n\nInto this one:\n\n```javascript\nfunction f(a, b, c) {\n    return [a, keyToValue(b), JSON.stringify(c)];\n}\n\nfunction manipulateObj(largeObj) {\n    var count = 0;\n    var name = null;\n    ...\n    p1.fire(f, count, name, largeObj);\n}\n```\n\nBe careful to avoid passing `.fire()` additional arguments that are\nthemselves expensive to construct, as that undermines the design goal\nhere: minimizing the effect of disabled probes.\n\nThis example creates a provider called \"nodeapp\", and adds two\nprobes. It then enables the provider, at which point the provider\nbecomes visible to DTrace.\n\nThe probes are then fired, which produces this output:\n\n    $ sudo dtrace -Z -n 'nodeapp*:::probe1{ trace(arg0); trace(arg1) }'  \\\n                     -n 'nodeapp*:::probe2{ trace(copyinstr(arg0));  }'\n    dtrace: description 'nodeapp*:::probe1' matched 0 probes\n    dtrace: description 'nodeapp*:::probe2' matched 0 probes\n    CPU     ID                    FUNCTION:NAME\n      1 123562                      func:probe1                 1                2\n      1 123563                      func:probe2   hello, dtrace                    \n\nArguments are captured by a callback only executed when the probe is\nenabled. This means you can do more expensive work to gather arguments.\n\nThe maximum number of arguments supported is 32. \n\nAvailable argument types are \"int\", for integer numeric values,\n\"char *\" for strings, and \"json\" for objects rendered into JSON strings.\n\nArguments typed as \"json\" will be created as \"char *\" probes in\nDTrace, but objects passed to these probe arguments will be\nautomatically serialized to JSON before being passed to DTrace. This\nfeature is best used in conjunction with the json() D subroutine, but\nis available whether or not the platform supports it.\n\n    # create a json probe:\n\n    var dtp = d.createDTraceProvider(\"nodeapp\");\n    var p1 = dtp.addProbe(\"j1\", \"json\");\n    dtp.enable();\n    p1.fire(function() { return { \"foo\": \"bar\" }; });\n\n    # on a platform supporting json():\n\n    $ sudo dtrace -Z -n 'nodeapp*:::j1{ this->j = copyinstr(arg0); \\\n                                        trace(json(this->j, \"foo\")) }'\n    dtrace: description 'nodeapp$target:::j1' matched 0 probes\n    CPU     ID                    FUNCTION:NAME\n      0  68712                            j1:j1   bar\n\n## PLATFORM SUPPORT\n\nThis libusdt-based Node.JS module supports 64 and 32 bit processes on\nMac OS X and Solaris-like systems such as illumos or SmartOS. As more\nplatform support is added to libusdt, those platforms will be\nsupported by this module. See libusdt's status at:\n\n  https://github.com/chrisa/libusdt#readme\n\nFreeBSD is supported in principle but is restricted to only 4 working\narguments per probe.\n\nPlatforms not supporting DTrace (notably, Linux and Windows) may\ninstall this module without building libusdt, with a stub no-op\nimplementation provided for compatibility. This allows cross-platform\nnpm modules to embed probes and include a dependency on this module.\n\nGNU Make is required to build libusdt; the build scripts will look for\ngmake in PATH first, and then for make.\n\n## CAVEATS\n\nThere is some overhead to probes, even when disabled. Probes are\nalready using the \"is-enabled\" feature of DTrace to control execution\nof the arguments-gathering callback, but some work still needs to be\ndone before that's checked. This overhead should not be a problem\nunless probes are placed in particularly hot code paths.\n\n## CONTRIBUTING\n\nThe source is available at:\n\n  https://github.com/chrisa/node-dtrace-provider\n\nFor issues, please use the GitHub issue tracker linked to the\nrepository. GitHub pull requests are very welcome.\n\n## RUNNING THE TESTS\n\n```shell\n$ npm install\n$ sudo ./node_modules/.bin/tap --tap test/*.test.js\n```\n\n## OTHER IMPLEMENTATIONS\n\nThis node extension is derived from the ruby-dtrace gem, via the Perl\nmodule Devel::DTrace::Provider, both of which provide the same\nfunctionality to those languages.\n",
  "readmeFilename": "README.md",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/chrisa/node-dtrace-provider.git"
  },
  "scripts": {
    "install": "node scripts/install.js",
    "test": "tap test/*test.js"
  },
  "version": "0.8.1"
}
